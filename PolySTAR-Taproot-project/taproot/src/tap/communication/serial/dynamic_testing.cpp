/*****************************************************************************/
/********** !!! WARNING: CODE GENERATED BY TAPROOT. DO NOT EDIT !!! **********/
/*****************************************************************************/

/*
 * Copyright (c) 2020-2022 Advanced Robotics at the University of Washington <robomstr@uw.edu>
 *
 * This file is part of Taproot.
 *
 * Taproot is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Taproot is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Taproot.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "dynamic_testing.hpp"

#include "tap/algorithms/math_user_utils.hpp"
#include "tap/architecture/clock.hpp"
#include "tap/communication/serial/uart.hpp"
#include "tap/drivers.hpp"
#include "tap/errors/create_errors.hpp"

#include "remote_serial_constants.hpp"

namespace tap::communication::serial
{
template <typename T>
void DynamicTesting<T>::initialize()
{
    drivers->uart.init<bound_ports::DYNAMIC_TESTING_SERIAL_UART_PORT, 100000, Uart::Parity::Even>();
}

template <typename T>
void DynamicTesting<T>::read()
{
    // Check disconnect timeout
    if (tap::arch::clock::getTimeMilliseconds() - lastRead > DISCONNECT_TIMEOUT)
    {
        connected = false;  // Remote no longer connected
        reset();            // Reset current remote values
    }
    uint8_t data;  // Next byte to be read
    // Read next byte if available and more needed for the current packet
    int realBufferLength = MAX_BUF_LEN;
    bool coded = false;
    Code code;
    while (drivers->uart.read(bound_ports::DYNAMIC_TESTING_SERIAL_UART_PORT, &data) &&
           currentBufferIndex < realBufferLength)
    {
        rxBuffer[currentBufferIndex] = data;
        currentBufferIndex++;
        lastRead = tap::arch::clock::getTimeMilliseconds();
        if (!coded && currentBufferIndex == 2) {
            AbstractCodeData acd = this->getCodeStruct(data);
            realBufferLength = acd.byteLength;
            code = acd.code;
            coded = true;
        } 
    }
    // Check read timeout
    if (tap::arch::clock::getTimeMilliseconds() - lastRead > READ_TIMEOUT || code == Code::ERROR)
    {
        clearRxBuffer();
    }
    // Parse buffer if all 18 bytes are read
    if (code != Code::ERROR && currentBufferIndex >= realBufferLength)
    {
        connected = true;
        parseSmoothPidBuffer();
        clearRxBuffer();
    }
}

template <typename T>
bool DynamicTesting<T>::isConnected() const { return connected; }

template <typename T>
void DynamicTesting<T>::parseSmoothPidBuffer()
{
    smoothPidData.kp                  = rxBuffer[3]  << 8 | rxBuffer[4]  << 16 | rxBuffer[5]  << 24 | rxBuffer[6]  << 32;
    smoothPidData.ki                  = rxBuffer[7]  << 8 | rxBuffer[8]  << 16 | rxBuffer[9]  << 24 | rxBuffer[10] << 32;
    smoothPidData.kd                  = rxBuffer[11] << 8 | rxBuffer[12] << 16 | rxBuffer[13] << 24 | rxBuffer[14] << 32;
    smoothPidData.maxICumulative      = rxBuffer[15] << 8 | rxBuffer[16] << 16 | rxBuffer[17] << 24 | rxBuffer[18] << 32;
    smoothPidData.maxOutput           = rxBuffer[19] << 8 | rxBuffer[20] << 16 | rxBuffer[21] << 24 | rxBuffer[22] << 32;
    smoothPidData.QDerivativeKalman   = rxBuffer[23] << 8 | rxBuffer[24] << 16 | rxBuffer[25] << 24 | rxBuffer[26] << 32;
    smoothPidData.RDerivativeKalman   = rxBuffer[27] << 8 | rxBuffer[28] << 16 | rxBuffer[29] << 24 | rxBuffer[30] << 32;
    smoothPidData.QProportionalKalman = rxBuffer[31] << 8 | rxBuffer[32] << 16 | rxBuffer[33] << 24 | rxBuffer[34] << 32;
    smoothPidData.RProportionalKalman = rxBuffer[35] << 8 | rxBuffer[36] << 16 | rxBuffer[37] << 24 | rxBuffer[38] << 32;
    system.resetPid(smoothPidData.kp, smoothPidData.ki, smoothPidData.kd, smoothPidData.maxICumulative, smoothPidData.maxOutput);
}

template <typename T>
void DynamicTesting<T>::clearRxBuffer()
{
    // Reset bytes read counter
    currentBufferIndex = 0;
    // Clear remote rxBuffer
    for (int i = 0; i < MAX_BUF_LEN; i++)
    {
        rxBuffer[i] = 0;
    }
    // Clear Usart1 rxBuffer
    drivers->uart.discardReceiveBuffer(bound_ports::DYNAMIC_TESTING_SERIAL_UART_PORT);
}

template <typename T>
void DynamicTesting<T>::reset() {}

template <typename T>
DynamicTesting<T>::AbstractCodeData DynamicTesting<T>::getCodeStruct(uint8_t code) {
    switch (code)
    {
    case DynamicTesting::Code::SMOOTH_PID:
        return smoothPidData;
    
    case DynamicTesting::Code::FRICTION_COMPENSATION:
        return frictionCompensationData;
    
    case DynamicTesting::Code::GRAVITY_COMPENSATION:
        return gravityCompensationData;
    
    case DynamicTesting::Code::AUTOMATIC_UNJAMMING:
        return automaticUnjammingData;

    default:
        return errorData;
    }
}

}  // namespace tap::communication::serial
