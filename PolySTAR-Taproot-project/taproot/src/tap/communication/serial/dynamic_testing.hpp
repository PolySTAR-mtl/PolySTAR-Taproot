/*****************************************************************************/
/********** !!! WARNING: CODE GENERATED BY TAPROOT. DO NOT EDIT !!! **********/
/*****************************************************************************/

/*
 * Copyright (c) 2020-2022 Advanced Robotics at the University of Washington <robomstr@uw.edu>
 *
 * This file is part of Taproot.
 *
 * Taproot is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Taproot is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Taproot.  If not, see <https://www.gnu.org/licenses/>.
 */


#ifndef TAPROOT_REMOTE_HPP_
#define TAPROOT_REMOTE_HPP_

#include <cstdint>

#ifndef PLATFORM_HOSTED
#include "modm/platform.hpp"
#endif

#include "tap/util_macros.hpp"
#include "tap/control/subsystem.hpp"

namespace tap
{
class Drivers;
}

namespace tap::communication::serial
{
/**
 * A unique UART handler that uses timing in leu of DBUS communication (modm does not
 * support DBUS) to interact with the DR16 receiver.
 *
 * Information for implementation was translated from a user manual for the DR16 that was
 * only available in Chinese. AI-Translated version of document available here:
 * https://drive.google.com/file/d/1-ZGe4mXVhxP4IEmHccphnzKzYWJyw3C3/view?usp=sharing
 */
template <typename T>
class DynamicTesting
{
public:
    DynamicTesting(Drivers *drivers, T system) : drivers(drivers), system(system) {}
    DISALLOW_COPY_AND_ASSIGN(DynamicTesting)
    mockable ~DynamicTesting() = default;

    enum Code : uint8_t {
        SMOOTH_PID,
        FRICTION_COMPENSATION,
        GRAVITY_COMPENSATION,
        AUTOMATIC_UNJAMMING,
        ERROR,
    };

    struct AbstractCodeData {
        AbstractCodeData() {};
        Code const code;
        const int byteLength;
    };


    /**
     * Enables and initializes `bound_ports::REMOTE_SERIAL_UART_PORT`.
     */
    mockable void initialize();

    /**
     * Reads/parses the current buffer and updates the current remote info state
     * and `CommandMapper` state.
     */
    mockable void read();

    /**
     * @return `true` if the remote is connected, `false` otherwise.
     * @note A timer is used to determine if the remote is disconnected, so expect a
     *      second or so of delay from disconnecting the remote to this function saying
     *      the remote is disconnected.
     */
    mockable bool isConnected() const;

    mockable AbstractCodeData getCodeStruct(uint8_t code);


    /**
     * @return the number of times remote info has been received.
     */
    mockable uint32_t getUpdateCounter() const;

private:

    /// The current remote information
    struct SmoothPidData : public AbstractCodeData
    {
        Code const code = Code::SMOOTH_PID;
        int const byteLength = 36;
        uint32_t kp = 0;
        uint32_t ki = 0;
        uint32_t kd = 0;
        uint32_t maxICumulative = 0;
        uint32_t maxOutput = 0;
        uint32_t QDerivativeKalman = 0;
        uint32_t RDerivativeKalman = 0;
        uint32_t QProportionalKalman = 0;
        uint32_t RProportionalKalman = 0;
    };
    struct FrictionCompensationData : public AbstractCodeData
    {
        Code const code = Code::FRICTION_COMPENSATION;
        int const byteLength = 8;
        uint32_t ks = 0;
        uint32_t velCutoff = 0;

    };
    struct GravityCompensationData : public AbstractCodeData
    {
        Code const code = Code::GRAVITY_COMPENSATION;
        int const byteLength = 4;
        uint32_t kg = 0;

    };
    struct AutomaticUnjammingData : public AbstractCodeData
    {
        Code const code = Code::AUTOMATIC_UNJAMMING;
        int const byteLength = 40;
        uint32_t targetDisplacement = 0;
        uint32_t moveTime = 0;
        uint32_t pauseAfterMoveTime = 0;
        uint32_t setPointTolerance = 0;
        uint32_t unjamThreshold = 0;
        uint32_t maxWaitTime = 0;
        uint32_t targetCycleCount = 0;
        uint32_t distanceTolerance = 0;
        uint16_t temporalTolerance = 0;
    };
    struct ErrorData : public AbstractCodeData
    {
        Code const code = Code::ERROR;
        int const byteLength = 0;

    };
    SmoothPidData smoothPidData;
    FrictionCompensationData frictionCompensationData;
    GravityCompensationData gravityCompensationData;
    AutomaticUnjammingData automaticUnjammingData;
    ErrorData errorData;
    
    static const int MAX_BUF_LEN = 40;              ///< Length of the remote recieve buffer.
    static const int READ_TIMEOUT = 6;          ///< Timeout delay between valid packets.
    static const int DISCONNECT_TIMEOUT = 100;  ///< Timeout delay for remote disconnect.
    static const int INT_PRI = 12;              ///< Interrupt priority.
    

    Drivers *drivers;

    /// Remote connection state.
    bool connected = false;

    /// UART recieve buffer.
    uint8_t rxBuffer[MAX_BUF_LEN]{0};

    /// Timestamp when last byte was read (milliseconds).
    uint32_t lastRead = 0;

    /// Current count of bytes read.
    uint8_t currentBufferIndex = 0;

    T system;

    /// Parses the current rxBuffer.
    void parseSmoothPidBuffer();
    // void parseFrictionCompensationBuffer();
    // void parseGravityCompensationBuffer();
    // void parseAutomaticUnjammingBuffer();

    /// Clears the current rxBuffer.
    void clearRxBuffer();

    /// Resets the current remote info.
    void reset();
};  // class Remote

}  // namespace tap::communication::serial

#endif  // TAPROOT_REMOTE_HPP_
